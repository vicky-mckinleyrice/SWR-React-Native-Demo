{"version":3,"file":"swr-react-native.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["import useSWR, { SWRResponse, SWRConfiguration, Key,   } from 'swr'\nimport { useRef, useEffect } from 'react'\nimport { AppState, Platform } from 'react-native'\nimport { useNavigation } from '@react-navigation/native'\nimport type NetInfo from '@react-native-community/netinfo'\nimport type { NetInfoState } from '@react-native-community/netinfo'\n\ntype Props<Data, Error> = {\n  /**\n   * Required: pass the `mutate` function returned to you by SWR.\n   */\n  mutate: SWRResponse<Data, Error>['mutate']\n} & Pick<\n  SWRConfiguration,\n  'revalidateOnFocus' | 'revalidateOnReconnect' | 'focusThrottleInterval'\n>\n\n/**\n * swr-react-native\n *\n * This helps you revalidate your SWR calls, based on navigation actions in `react-navigation`.\n */\nexport function useSWRNativeRevalidate<Data = any, Error = any>(\n  props: Props<Data, Error>\n) {\n  const {\n    mutate,\n    // copy defaults from SWR\n    revalidateOnFocus = true,\n    revalidateOnReconnect = true,\n    focusThrottleInterval = 5000,\n  } = props\n\n  const { addListener } = useNavigation()\n\n  const lastFocusedAt = useRef<number | null>(null)\n  const fetchRef = useRef(mutate)\n  useEffect(() => {\n    fetchRef.current = mutate\n  })\n  const focusCount = useRef(\n    Platform.select({\n      // react-navigation fire a focus event on the initial mount, but not on web\n      web: 1,\n      default: 0,\n    })\n  )\n\n  const previousAppState = useRef(AppState.currentState)\n  const previousNetworkState = useRef<NetInfoState | null>(null)\n\n  useEffect(() => {\n    let unsubscribeReconnect: ReturnType<\n      typeof NetInfo.addEventListener\n    > | null = null\n    if (revalidateOnReconnect && Platform.OS !== 'web') {\n      // inline require to avoid breaking SSR when window doesn't exist\n      const Network: typeof NetInfo = require('@react-native-community/netinfo')\n        .default\n      // SWR does all of this on web.\n      unsubscribeReconnect = Network.addEventListener((state) => {\n        if (\n          previousNetworkState.current?.isInternetReachable === false &&\n          state.isConnected &&\n          state.isInternetReachable\n        ) {\n          fetchRef.current()\n        }\n        previousNetworkState.current = state\n      })\n    }\n\n    const onFocus = () => {\n      if (focusCount.current < 1) {\n        focusCount.current++\n        return\n      }\n      const isThrottled =\n        focusThrottleInterval &&\n        lastFocusedAt.current &&\n        Date.now() - lastFocusedAt.current <= focusThrottleInterval\n\n      if (!isThrottled) {\n        lastFocusedAt.current = Date.now()\n        fetchRef.current()\n      }\n    }\n\n    const onAppStateChange = (nextAppState: AppState['currentState']) => {\n      if (\n        previousAppState.current.match(/inactive|background/) &&\n        nextAppState === 'active' &&\n        // swr handles this on web.\n        Platform.OS !== 'web'\n      ) {\n        onFocus()\n      }\n\n      previousAppState.current = nextAppState\n    }\n\n    let unsubscribeFocus: ReturnType<typeof addListener> | null = null\n\n    if (revalidateOnFocus) {\n      unsubscribeFocus = addListener('focus', onFocus)\n      AppState.addEventListener('change', onAppStateChange)\n    }\n\n    return () => {\n      if (revalidateOnFocus) {\n        unsubscribeFocus?.()\n        AppState.removeEventListener('change', onAppStateChange)\n      }\n      if (revalidateOnReconnect) {\n        unsubscribeReconnect?.()\n      }\n    }\n  }, [\n    addListener,\n    focusThrottleInterval,\n    revalidateOnFocus,\n    revalidateOnReconnect,\n  ])\n}\n\ntype Fetcher<Data> = ((...args: any) => Data | Promise<Data>) | null\n\n\nconst useSWRNative = <Data = any, Error = any>(\n  key: Key,\n  fn: Fetcher<Data> = null,\n  config?: SWRConfiguration<Data, Error>\n) => {\n  const swr = useSWR<Data, Error>(key, fn, config)\n\n  useSWRNativeRevalidate({\n    mutate: swr.mutate,\n    revalidateOnFocus: config?.revalidateOnFocus,\n    revalidateOnReconnect: config?.revalidateOnReconnect,\n    focusThrottleInterval: config?.focusThrottleInterval,\n  })\n\n  return swr\n}\n\nexport default useSWRNative"],"names":["useSWRNativeRevalidate","props","mutate","revalidateOnFocus","revalidateOnReconnect","focusThrottleInterval","addListener","useNavigation","lastFocusedAt","useRef","fetchRef","useEffect","current","focusCount","Platform","select","web","previousAppState","AppState","currentState","previousNetworkState","unsubscribeReconnect","OS","Network","require","addEventListener","state","isInternetReachable","isConnected","onFocus","Date","now","onAppStateChange","nextAppState","match","unsubscribeFocus","removeEventListener","key","fn","config","swr","useSWR"],"mappings":"0OAsBgBA,EACdC,OAGEC,EAKED,EALFC,SAKED,EAHFE,kBAAAA,kBAGEF,EAFFG,sBAAAA,kBAEEH,EADFI,sBAAAA,aAAwB,MAGlBC,EAAgBC,kBAAhBD,YAEFE,EAAgBC,SAAsB,MACtCC,EAAWD,SAAOP,GACxBS,aAAU,WACRD,EAASE,QAAUV,SAEfW,EAAaJ,SACjBK,WAASC,OAAO,CAEdC,IAAK,UACI,KAIPC,EAAmBR,SAAOS,WAASC,cACnCC,EAAuBX,SAA4B,MAEzDE,aAAU,eACJU,EAEO,QACPjB,GAAyC,QAAhBU,WAASQ,GAAc,KAE5CC,EAA0BC,QAAQ,2CAGxCH,EAAuBE,EAAQE,kBAAiB,SAACC,UAES,cAAtDN,EAAqBR,kBAASe,sBAC9BD,EAAME,aACNF,EAAMC,qBAENjB,EAASE,UAEXQ,EAAqBR,QAAUc,SAI7BG,EAAU,WACVhB,EAAWD,QAAU,EACvBC,EAAWD,UAIXP,GACAG,EAAcI,SACdkB,KAAKC,MAAQvB,EAAcI,SAAWP,IAGtCG,EAAcI,QAAUkB,KAAKC,MAC7BrB,EAASE,YAIPoB,EAAmB,SAACC,GAEtBhB,EAAiBL,QAAQsB,MAAM,wBACd,WAAjBD,GAEgB,QAAhBnB,WAASQ,IAETO,IAGFZ,EAAiBL,QAAUqB,GAGzBE,EAA0D,YAE1DhC,IACFgC,EAAmB7B,EAAY,QAASuB,GACxCX,WAASO,iBAAiB,SAAUO,IAG/B,WACD7B,UACFgC,GAAAA,IACAjB,WAASkB,oBAAoB,SAAUJ,IAErC5B,UACFiB,GAAAA,QAGH,CACDf,EACAD,EACAF,EACAC,oBAOiB,SACnBiC,EACAC,EACAC,YADAD,IAAAA,EAAoB,UAGdE,EAAMC,EAAoBJ,EAAKC,EAAIC,UAEzCvC,EAAuB,CACrBE,OAAQsC,EAAItC,OACZC,wBAAmBoC,SAAAA,EAAQpC,kBAC3BC,4BAAuBmC,SAAAA,EAAQnC,sBAC/BC,4BAAuBkC,SAAAA,EAAQlC,wBAG1BmC"}